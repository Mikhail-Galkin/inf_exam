# Ответы на билеты по информатике
![](./img.jpg)
## Билет 1: Непозиционные и позиционные системы счисления

**Непозиционные системы счисления** – системы, в которых значение цифры не зависит от её позиции в числе. Примеры: римская система (I, V, X, L, C, D, M), где V = 5 независимо от позиции.

**Позиционные системы счисления** – системы, в которых значение цифры зависит от её позиции в числе.

**Основание системы** – количество цифр в системе. Например, в десятичной системе основание = 10, в двоичной = 2, в восьмеричной = 8, в шестнадцатеричной = 16.

**Базисные числа** – цифры, используемые в системе (0-9 в десятичной, 0-1 в двоичной).

**Вес разряда** – значение позиции. Для числа 345₁₀: цифра 3 имеет вес 10², цифра 4 – вес 10¹, цифра 5 – вес 10⁰.

Пример: 345₁₀ = 3×10² + 4×10¹ + 5×10⁰ = 300 + 40 + 5

---

## Билет 2: Алгоритм замещения при переводе чисел

**Алгоритм замещения** используется для перевода целого числа из десятичной системы в другую.

**Процесс:**
1. Разложить число по степеням основания
2. Вычислить сумму

Пример: Перевести 19₁₀ в двоичную систему.
19₁₀ = 1×16 + 0×8 + 0×4 + 1×2 + 1×1 = 1×2⁴ + 0×2³ + 0×2² + 1×2¹ + 1×2⁰ = 10011₂

Пример 2: 52₁₀ в восьмеричную
52 = 6×8 + 4×1 = 6×8¹ + 4×8⁰ = 64₈

---

## Билет 3: Алгоритм целочисленного деления

**Алгоритм целочисленного деления** для перевода из 10-чной в другую систему:
1. Делить число на основание новой системы
2. Остаток – цифра в новой системе
3. Частное – основа для следующего деления
4. Повторять до получения частного 0
5. Остатки в обратном порядке – результат

Пример: 19₁₀ в двоичную
- 19 ÷ 2 = 9 (остаток 1)
- 9 ÷ 2 = 4 (остаток 1)
- 4 ÷ 2 = 2 (остаток 0)
- 2 ÷ 2 = 1 (остаток 0)
- 1 ÷ 2 = 0 (остаток 1)

Результат: 19₁₀ = 10011₂

Пример 2: 123₁₀ в восьмеричную
- 123 ÷ 8 = 15 (остаток 3)
- 15 ÷ 8 = 1 (остаток 7)
- 1 ÷ 8 = 0 (остаток 1)

Результат: 123₁₀ = 173₈

---

## Билет 4: Алгоритм последовательного умножения

**Алгоритм последовательного умножения** для перевода дробной части числа:
1. Дробь умножить на основание новой системы
2. Целая часть результата – цифра в новой системе
3. Дробная часть результата – основа для следующего умножения
4. Повторять до нужной точности

Пример: 0,625₁₀ в двоичную
- 0,625 × 2 = 1,25 → цифра 1, дробь 0,25
- 0,25 × 2 = 0,5 → цифра 0, дробь 0,5
- 0,5 × 2 = 1,0 → цифра 1, дробь 0

Результат: 0,625₁₀ = 0,101₂

Пример 2: 0,4₁₀ в восьмеричную (3 знака)
- 0,4 × 8 = 3,2 → цифра 3
- 0,2 × 8 = 1,6 → цифра 1
- 0,6 × 8 = 4,8 → цифра 4

Результат: 0,4₁₀ ≈ 0,314₈

---

## Билет 5: Алгоритм группирования

**Алгоритм группирования** используется для перевода между системами, основания которых связаны степенной зависимостью (8=2³, 16=2⁴).

**Для перевода из двоичной в восьмеричную:** разделить на группы по 3 бита слева направо
Пример: 101110101₂ = 101|110|101 = 565₈

**Для перевода из двоичной в шестнадцатеричную:** разделить на группы по 4 бита
Пример: 11111010₂ = 1111|1010 = FA₁₆

**Обратный процесс:** каждую цифру заменить группой битов
Пример: 7₈ = 111₂, 3₈ = 011₂, поэтому 73₈ = 111011₂

---

## Билет 6: Алгоритм расщепления

**Алгоритм расщепления** (или распределение) – обратный процесс группирования.

Каждую цифру одной системы заменяют группой цифр другой системы.

Пример: Перевести 1F₁₆ в двоичную
- 1₁₆ = 0001₂
- F₁₆ = 1111₂
Результат: 1F₁₆ = 00011111₂ = 11111₂

Пример 2: Перевести A5₁₆ в восьмеричную (через двоичную)
- A₁₆ = 1010₂, 5₁₆ = 0101₂
- 10100101₂ = 010|100|101 = 245₈

---

## Билет 7: Сложение и вычитание двоичных чисел

**Правила сложения в двоичной системе:**
- 0 + 0 = 0
- 0 + 1 = 1
- 1 + 0 = 1
- 1 + 1 = 10 (0 и перенос 1)
- 1 + 1 + 1 = 11 (1 и перенос 1)

Пример: 1011₂ + 1101₂
```
  1011
+ 1101
------
 11000₂
```

**Правила вычитания:**
- 0 - 0 = 0
- 1 - 0 = 1
- 1 - 1 = 0
- 0 - 1 = 1 (с заимствованием 1)

Пример: 1101₂ - 1001₂
```
  1101
- 1001
------
  0100₂
```

---

## Билет 8: Умножение двоичных чисел

**Правила умножения:**
- 0 × 0 = 0
- 0 × 1 = 0
- 1 × 0 = 0
- 1 × 1 = 1

Пример: 1011₂ × 101₂
```
    1011
  ×  101
  ------
    1011  (1011 × 1)
   0000   (1011 × 0, сдвинуто)
  1011    (1011 × 1, сдвинуто)
  ------
  110111₂
```

Проверка: 1011₂ = 11₁₀, 101₂ = 5₁₀, 11 × 5 = 55₁₀ = 110111₂ ✓

---

## Билет 9: Деление двоичных чисел

**Деление двоичных чисел** выполняется как долгое деление в десятичной системе.

Пример: 1100₂ ÷ 11₂

```
    100₂
   ------
11 | 1100
     11
    -----
      00
```

Результат: 1100₂ ÷ 11₂ = 100₂ (12₁₀ ÷ 3₁₀ = 4₁₀)

Пример 2: 10101₂ ÷ 11₂ = 111₂ (остаток 0)
Проверка: 10101₂ = 21₁₀, 11₂ = 3₁₀, 21 ÷ 3 = 7₁₀ = 111₂ ✓

---

## Билет 10: Машинные коды

**Прямой код** – представление числа со знаком:
- Первый бит – знак (0 для +, 1 для -)
- Остальные биты – модуль числа

Пример: +5 = 0101, -5 = 1101 (в 4-битном представлении)

**Обратный код** – для отрицательных чисел инвертируют все биты:
- +5 = 0101
- -5 = 1010 (обратный код: инверсия каждого бита)

**Дополнительный код** – обратный код + 1:
- -5 = 1010 + 1 = 1011

Пример для 8 бит:
- +23 = 00010111
- -23 прямой = 10010111
- -23 обратный = 11101000
- -23 дополнительный = 11101001

---

## Билет 11: Арифметические операции с отрицательными числами в обратном коде

В обратном коде сложение выполняется обычным образом, но если есть перенос из старшего бита, его добавляют к младшему биту.

Пример: 5 + (-3) в обратном коде (4 бита)
- 5 = 0101
- -3: прямой 1011, обратный 1100
```
  0101
+ 1100
------
 10001
```
Переносим единицу из старшего бита в младший: 0001 + 1 = 0010 = 2 ✓

Пример: (-5) + (-3) в обратном коде
- -5: прямой 1101, обратный 1010
- -3: прямой 1011, обратный 1100
```
  1010
+ 1100
------
 10110
```
Переносим: 0110 + 1 = 0111 → инвертируем (т.к. отрицательный) = 1000 → прямой код = -8 ✓

---

## Билет 12: Арифметические операции с отрицательными числами в дополнительном коде

В дополнительном коде операции выполняются обычным образом, переносы из старшего бита игнорируются.

Пример: 5 + (-3) в дополнительном коде (4 бита)
- 5 = 0101
- -3: дополнительный = 1101
```
  0101
+ 1101
------
 10010
```
Игнорируем перенос: результат 0010 = 2 ✓

Пример: (-5) + (-3)
- -5 = 1011
- -3 = 1101
```
  1011
+ 1101
------
 11000
```
Результат 1000 – это дополнительный код, прямой: -8 ✓

Преимущество дополнительного кода: универсальные правила сложения для положительных и отрицательных чисел.

---

## Билет 13: Представление чисел с фиксированной запятой

**Разрядная сетка с фиксированной запятой** – запятая находится в одном и том же месте.

Структура (8 бит): [знак][целая часть][дробная часть]

Пример: число 5,5₁₀ = 0101,1000 (4 бита целая, 4 дробная)
- Целая часть: 5₁₀ = 0101₂
- Дробная часть: 0,5₁₀ = 0,1₂

Пример: число -3,25₁₀ = 1011,0100
- Целая часть: 3 = 0011
- Дробная часть: 0,25 = 0,01
- В дополнительном коде: 1100,1100

Диапазон (8 бит, 4+4): от -8 до +7,9375

---

## Билет 14: Представление чисел с плавающей запятой

**Разрядная сетка с плавающей запятой:** число = мантисса × основание^порядок

Структура (32 бита): [знак мантиссы][порядок][мантисса]

**Нормализованный вид:** мантисса лежит в диапазоне [1, основание)

Пример: 25₁₀ = 11001₂
- Нормализованный вид: 1,1001 × 2⁴
- Мантисса: 1,1001, порядок: 4

Пример 2: 0,25₁₀ = 0,01₂
- Нормализованный вид: 1,0 × 2⁻²
- Мантисса: 1,0, порядок: -2

В стандарте IEEE 754:
- 1 бит: знак
- 8 бит: порядок (смещение +127)
- 23 бита: мантисса (без старшей единицы)

---

## Билет 15: Арифметические действия с числами в плавающей запятой

**Сложение:**
1. Выравнять порядки (сдвинуть мантиссу меньшего числа)
2. Сложить мантиссы
3. Нормализовать результат

Пример: 1,5 × 2² + 1,0 × 2⁰
- 1,5 × 2² + 0,25 × 2² = 1,75 × 2² = 7

**Умножение:**
1. Перемножить мантиссы
2. Сложить порядки
3. Нормализовать результат

Пример: (1,5 × 2²) × (1,0 × 2³) = 1,5 × 1,0 × 2⁵ = 1,5 × 32 = 48

**Деление:**
1. Разделить мантиссы
2. Вычесть порядки
3. Нормализовать результат

Пример: (1,5 × 2⁴) ÷ (1,0 × 2²) = 1,5 × 2² = 6

---

## Билет 16: Двоичная булева алгебра

**Логическая переменная** – переменная, принимающая значение 0 или 1 (ложь или истина).

**Логическая функция** – функция, отображающая наборы логических переменных в множество {0, 1}.

**Таблица истинности** – таблица, показывающая значение функции для всех возможных наборов переменных.

Пример для функции f(x, y) = x AND y:

| x | y | f |
|---|---|---|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

**Применение булевой алгебры:**
- Проектирование логических схем
- Синтез цифровых устройств
- Анализ алгоритмов
- Сжатие данных и оптимизация

---

## Билет 17: Аксиомы булевой алгебры

Основные аксиомы (законы):

1. **Законы идемпотентности:**
   - x + x = x
   - x · x = x

2. **Законы нулевого и единичного элементов:**
   - x + 0 = x, x + 1 = 1
   - x · 0 = 0, x · 1 = x

3. **Законы инволюции (двойное отрицание):**
   - x̄̄ = x

4. **Законы Де Моргана:**
   - (x + y)̄ = x̄ · ȳ
   - (x · y)̄ = x̄ + ȳ

5. **Законы коммутативности:**
   - x + y = y + x
   - x · y = y · x

6. **Законы ассоциативности:**
   - x + (y + z) = (x + y) + z
   - x · (y · z) = (x · y) · z

7. **Законы дистрибутивности:**
   - x · (y + z) = x·y + x·z
   - x + y·z = (x+y)·(x+z)

8. **Закон противоречия:** x · x̄ = 0
9. **Закон исключённого третьего:** x + x̄ = 1

---

## Билет 18: Булевы теоремы для одной переменной

1. **Поглощение:**
   - x + x·y = x
   - x·(x+y) = x

2. **Склеивание:**
   - x·y + x·ȳ = x
   - (x+y)·(x+ȳ) = x

3. **Добавление терма:**
   - x + x̄·y = x + y
   - x·(x̄+y) = x·y

Примеры:
- x + x·0 = x (поглощение)
- 1·x + 1·x̄ = x + x̄ = 1 (исключённый третий)
- x·(x̄ + 1) = x·1 = x (упрощение)

---

## Билет 19: Булевы теоремы с несколькими переменными

1. **Консенсус:**
   - x·y + x̄·z + y·z = x·y + x̄·z

2. **Абсорбция (обобщённая):**
   - x·y + x·y·z = x·y
   - (x+y)·(x+y+z) = x+y

3. **Обобщённое склеивание:**
   - x·y + x̄·z = x·y + x̄·z + y·z
   - (x+y)·(x̄+z) = (x+y)·(x̄+z)·(y+z)

Пример: f(x,y,z) = xy + x̄z + yz
По теореме консенсуса: xy + x̄z (без yz)

---

## Билет 20: Основные логические элементы

**NOT (Инвертор):**
- Выход = NOT вход
- Таблица: 0→1, 1→0

**AND (И):**
- Выход = 1 если ВСЕ входы = 1
- 0·0=0, 0·1=0, 1·0=0, 1·1=1

**OR (ИЛИ):**
- Выход = 1 если хотя бы один вход = 1
- 0+0=0, 0+1=1, 1+0=1, 1+1=1

**NAND (И-НЕ):**
- Выход = NOT(x AND y)
- Универсальный элемент

**NOR (ИЛИ-НЕ):**
- Выход = NOT(x OR y)
- Универсальный элемент

**XOR (исключительное ИЛИ):**
- Выход = 1 если входы различны
- 0⊕0=0, 0⊕1=1, 1⊕0=1, 1⊕1=0

**XNOR (исключительное ИЛИ-НЕ):**
- Выход = 1 если входы одинаковы

---

## Билет 21: Классификация цифровых схем

**Комбинационные схемы** – выход зависит только от текущих значений входов, без памяти:
- Мультиплексор
- Демультиплексор
- Шифратор/Дешифратор
- Сумматор
- Компаратор

**Последовательностные схемы** – имеют память, выход зависит от истории входов:
- Триггеры (SR, JK, T, D)
- Счётчики
- Регистры
- Конечные автоматы

**Принципиальная логическая схема** – графическое представление логических функций с использованием логических элементов.

---

## Билет 22: Минтерм и дизъюнктивная нормальная форма

**Минтерм** – произведение всех переменных (с отрицанием или без), каждая переменная встречается ровно один раз.

Для f(x,y): минтермы: x̄ȳ, x̄y, xȳ, xy

**Полная элементарная конъюнкция** – то же, что минтерм.

**Дизъюнктивная нормальная форма (ДНФ)** – логическая сумма элементарных конъюнкций:
- f = xy + x̄z + yz

**Совершенная дизъюнктивная нормальная форма (СДНФ)** – ДНФ, где каждое слагаемое – минтерм:
- f(x,y) = x̄ȳ + x̄y + xy

Пример из таблицы истинности:
| x | y | f |
|---|---|---|
| 0 | 0 | 1 | ← x̄ȳ
| 0 | 1 | 0 |
| 1 | 0 | 1 | ← xȳ
| 1 | 1 | 0 |

СДНФ: f = x̄ȳ + xȳ = ȳ(x̄ + x) = ȳ

---

## Билет 23: Макстерм и конъюнктивная нормальная форма

**Макстерм** – сумма всех переменных (с отрицанием или без), каждая переменная встречается ровно один раз.

Для f(x,y): макстермы: x̄+ȳ, x̄+y, x+ȳ, x+y

**Полная элементарная дизъюнкция** – то же, что макстерм.

**Конъюнктивная нормальная форма (КНФ)** – логическое произведение элементарных дизъюнкций:
- f = (x + y) · (x̄ + z)

**Совершенная конъюнктивная нормальная форма (СКНФ)** – КНФ, где каждый множитель – макстерм:
- f(x,y) = (x̄ + ȳ) · (x̄ + y) · (x + ȳ)

Пример из таблицы истинности (где f = 0):
| x | y | f |
|---|---|---|
| 0 | 0 | 0 | ← (x+y)
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 | ← (x̄+ȳ)

СКНФ: f = (x+y) · (x̄+ȳ)

---

## Билет 24: Аналитический переход от нормальной к совершенной форме

**От ДНФ к СДНФ:**
1. Для каждого неполного члена умножить на (xᵢ + x̄ᵢ)
2. Раскрыть скобки
3. Исключить повторения

Пример: f = xy + z
- xy: добавить z, x̄z: 1+1=1 ✓
- xy(z + z̄) + z(xy + x̄y + x̄ȳ) = xyz + xyz̄ + xyz + x̄yz + x̄ȳz
- = xyz + xyz̄ + x̄yz + x̄ȳz (удалили повтор)

**От КНФ к СКНФ:**
1. Для каждого неполного множителя добавить дизъюнкцию (xᵢ · x̄ᵢ)
2. Раскрыть скобки

Пример: f = (x+y) · z
- (x+y)(z + 0) = (x+y)(z(x+x̄)) = (x+y)(zx + zx̄)
- = (x+y+z)(x+y+z̄)(x+z)(x̄+y+z) и т.д.

---

## Билет 25: Минимизация СДНФ методом последовательного исключения

**Метод последовательного исключения логических переменных:**
1. Выбрать переменную для исключения
2. Разбить функцию на две части (с переменной и без)
3. Применить законы булевой алгебры
4. Повторить для остальных переменных

Пример: f(x,y,z) = xyz + xyz̄ + x̄yz

Исключить z:
- f = xyz + xyz̄ + x̄yz = xy(z + z̄) + x̄yz = xy + x̄yz

Исключить x:
- f = xy + x̄yz = y(x + x̄z) = y(x + x̄z)

Исключить y (или продолжить с x):
- Минимальная форма: xy + x̄yz

---

## Билет 26: Построение СДНФ и СКНФ по таблице истинности

**СДНФ** – выписать минтермы для строк, где f = 1

Пример:
| x | y | z | f |
|---|---|---|---|
| 0 | 0 | 0 | 1 | ← x̄ȳz̄
| 0 | 0 | 1 | 0 |
| 0 | 1 | 0 | 1 | ← x̄yz̄
| 0 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 | ← xȳz̄
| 1 | 0 | 1 | 1 | ← xȳz
| 1 | 1 | 0 | 0 |
| 1 | 1 | 1 | 0 |

СДНФ: f = x̄ȳz̄ + x̄yz̄ + xȳz̄ + xȳz = ȳz̄(x̄ + x) + xȳ = ȳz̄ + xȳ

**СКНФ** – выписать макстермы для строк, где f = 0

СКНФ: f = (x + y + z) · (x + ȳ + z) · (x̄ + ȳ + z) · (x̄ + ȳ + z̄)

---

## Билет 27: Минимизация логических функций

**Цель:** найти минимальное представление функции (минимум членов и переменных).

**Методы:**
1. **Аналитический** – применение теорем булевой алгебры
2. **Карты Карно** – графический метод
3. **Диаграммы Вейча** – для 4-5 переменных
4. **Квайна-Мак-Класки** – табличный метод

**Критерии минимизации:**
- Минимум букв в выражении
- Минимум операций
- Минимум логических элементов в схеме

Пример: f = xy + xy̅ + x̅y = x(y + y̅) + x̅y = x + x̅y = x + y

---

## Билет 28: Минимизация методом карт Карно

**Карта Карно** – графический способ минимизации для 2-4 переменных.

Для 3 переменных (8 ячеек):
```
     yz
    00 01 11 10
x
0  [0][1][1][0]
1  [0][0][1][1]
```

**Правила:**
1. Заполнить ячейки значениями функции
2. Объединить соседние единицы в группы (по 2, 4, 8)
3. Выписать минтермы для каждой группы (переменные, которые не меняют значение)

Пример: f(x,y,z) = xȳz + xyz + xy
```
     yz
    00 01 11 10
x
0  [0][0][0][0]
1  [0][1][1][1]
```

Группа: xy (верхняя часть со строки x=1)
Результат: f = xy

---

## Билет 29: Минимизация методом диаграмм Вейча

**Диаграмма Вейча** – модификация карт Карно для систематической минимизации.

Для 4 переменных (16 ячеек):
```
    yz
   00 01 11 10
wx
00 [ ][ ][ ][ ]
01 [ ][ ][ ][ ]
11 [ ][ ][ ][ ]
10 [ ][ ][ ][ ]
```

**Процесс:**
1. Разместить функцию в диаграмму
2. Объединить единицы в прямоугольные группы
3. Выписать результирующую функцию

Соседство включает "обёртывание" краёв диаграммы (циклическое).

---

## Билет 30: Минимизация методом Квайна-Мак-Класки

**Метод Квайна-Мак-Класки** – табличный метод минимизации для любого числа переменных.

**Этапы:**
1. Преобразовать минтермы в двоичные коды
2. Сгруппировать по числу единиц
3. Провести первичное покрытие (склеивание)
4. Построить таблицу простых импликант
5. Выбрать минимальное покрытие

Пример для f(x,y,z) = Σ(1,3,5,7):
- Двоичные: 001, 011, 101, 111
- Первичные импликанты: xȳz + xyz + x̄ȳz + x̄yz = 1 (после склеивания)
- Минимум: z

---

## Билет 31: Правила изображения принципиальных логических схем

**Правила ГОСТ:**
1. **Обозначение элементов:**
   - NOT: треугольник с кругом на выходе
   - AND: выпуклый символ &
   - OR: символ ≥1
   - NAND: & с кругом
   - NOR: ≥1 с кругом

2. **Соединение:**
   - Входы слева, выходы справа
   - Провода – прямые линии
   - Пересечения без соединения – дуга

3. **Альтернативные обозначения:**
   - MIL-стандарт (прямоугольники с буквами)
   - IEC-стандарт (символы 1, &, ≥1)

---

## Билет 32: Анализ комбинационных логических схем

**Анализ** – определение функции схемы по её диаграмме.

**Процесс:**
1. Пронумеровать все элементы
2. Выписать функцию для каждого элемента
3. Подставлять функции до выхода
4. Упростить полученное выражение

Пример:
```
      x─┬─[AND]─┐
        │        [OR]─ f
      y─┴─[OR]──┘
```

1. Первый AND: x·y
2. OR: y (т.к. y + (x·y) = y)
3. Второй OR: x + y = f

Таблица истинности: f = x + y (дизъюнкция)

---

## Билет 33: Синтез комбинационных логических схем

**Синтез** – построение схемы по логическому выражению.

**Этапы:**
1. Получить логическое выражение (из таблицы истинности или словесно)
2. Минимизировать выражение
3. Выбрать элементы (AND, OR, NOT)
4. Нарисовать схему по выражению

Пример: f(x,y) = x + y
```
x─────┐
      [OR]─ f
y─────┘
```

Сложный пример: f = xy + x̄z
```
x─────[AND]──┐
y────────────┘
              [OR]─ f
x̄────[AND]──┐
z────────────┘
```

---

## Билет 34: Элементы комбинаторики

**Перестановки** – упорядоченные наборы всех элементов:
- P(n) = n! = 1×2×3×...×n
- Пример: P(3) = 3! = 6 (ABC, ACB, BAC, BCA, CAB, CBA)

**Сочетания** – неупорядоченные подмножества:
- C(n,k) = n! / (k!(n-k)!)
- Пример: C(5,2) = 5!/(2!3!) = 10

**Сочетания с повторениями:**
- C̄(n,k) = (n+k-1)! / (k!(n-1)!)
- Пример: выбрать 3 предмета из 2 видов: C̄(2,3) = 4

**Размещения** – упорядоченные подмножества:
- A(n,k) = n! / (n-k)!
- Пример: A(5,2) = 5×4 = 20

---

## Билет 35: Случайные события и вероятность

**Случайное событие** – событие, которое может произойти или не произойти при данных условиях.

**Виды событий:**
- **Достоверное** – произойдёт всегда (вероятность = 1)
- **Невозможное** – не произойдёт никогда (вероятность = 0)
- **Случайное** – может произойти (0 < P < 1)

**Исход** – результат одного опыта/испытания.

**Вероятность события** – отношение благоприятных исходов к общему числу:
- P(A) = m/n

Пример: вероятность выпадения "орла" при бросании монеты = 1/2 = 0,5

Пример 2: вероятность выпадения 6 на кубике = 1/6 ≈ 0,167

---

## Билет 36: Сумма событий и правило сложения вероятностей

**Сумма событий** A + B – произойдёт событие A или B (или оба).

**Правило сложения вероятностей:**
- Для несовместных событий: P(A+B) = P(A) + P(B)
- Для совместных событий: P(A+B) = P(A) + P(B) - P(A·B)

Пример 1: вероятность выпадения чётного числа (2,4,6) на кубике:
- P(чётное) = P(2) + P(4) + P(6) = 1/6 + 1/6 + 1/6 = 1/2

Пример 2: вероятность вытащить туз или пику из колоды:
- P(туз или пика) = P(туз) + P(пика) - P(туз пики)
- = 4/52 + 13/52 - 1/52 = 16/52 = 4/13

---

## Билет 37: Условные вероятности и правило умножения

**Условная вероятность** P(A|B) – вероятность события A при условии, что произошло B:
- P(A|B) = P(A·B) / P(B)

**Правило умножения вероятностей:**
- P(A·B) = P(A) × P(B|A) = P(B) × P(A|B)

**Для независимых событий:**
- P(A·B) = P(A) × P(B)

Пример: вероятность вытащить две пики подряд из колоды:
- P(1-я пика) = 13/52 = 1/4
- P(2-я пика | 1-я пика) = 12/51
- P(обе пики) = (13/52) × (12/51) ≈ 0,059

---

## Билет 38: Бинарная энтропийная функция Шеннона

**Бинарная энтропия Шеннона:**
- H(p) = -p·log₂(p) - (1-p)·log₂(1-p), где p ∈ [0,1]

**При подбрасывании несимметричной монеты n раз:**
Количество информации = n × H(p)

Пример: монета с p=0,7 (вероятность "орла"):
- H(0,7) = -0,7·log₂(0,7) - 0,3·log₂(0,3) ≈ 0,881 бита

При 10 бросаниях: информация ≈ 10 × 0,881 ≈ 8,81 бита

Справедливая монета (p=0,5):
- H(0,5) = 1 бит
- 10 бросаний = 10 бит информации

---

## Билет 39: Энтропия источника алфавита

**Энтропия источника** – средняя информация, приходящаяся на один символ:
- H = Σ pᵢ · log₂(1/pᵢ) = -Σ pᵢ·log₂(pᵢ)

где pᵢ – вероятность символа i.

**Для бинарного алфавита:**
- H(p) = -p·log₂(p) - (1-p)·log₂(1-p)

**Для произвольного алфавита** (n символов с вероятностями p₁, p₂, ..., pₙ):
- H = -Σᵢ₌₁ⁿ pᵢ·log₂(pᵢ)

Пример: алфавит {A:0,5, B:0,25, C:0,125, D:0,125}
- H = -0,5·1 - 0,25·2 - 0,125·3 - 0,125·3
- = -0,5 - 0,5 - 0,375 - 0,375 = 1,75 бита/символ

---

## Билет 40: Мера информации и свойства энтропии

**Мера информации** – количество неопределённости, устраняемой при получении сообщения.

**Свойства энтропии:**
1. **Неотрицательность:** H ≥ 0
2. **Максимум:** H_max = log₂(n) при равновероятных символах
3. **Адитивность:** H(X,Y) = H(X) + H(Y|X)
4. **Монотонность:** добавление новых символов не уменьшает энтропию
5. **Непрерывность:** функция непрерывна по вероятностям

Пример: равномерный алфавит (4 символа, p = 0,25):
- H_max = log₂(4) = 2 бита/символ

Неравномерный алфавит ({A:0,9, B:0,1}):
- H = -0,9·log₂(0,9) - 0,1·log₂(0,1) ≈ 0,469 < 1 бит

---

## Билет 41: Мера информации по Хартли и Шеннону

**Мера Хартли** (уравномерное распределение):
- I = log₂(N)

где N – количество равновероятных сообщений.

Пример: 8 равновероятных сообщений → I = log₂(8) = 3 бита

**Мера Шеннона** (для неравномерного распределения):
- I = Σ pᵢ·log₂(1/pᵢ)

**Связь:**
- Мера Шеннона ≤ Мера Хартли (с равенством при p₁ = p₂ = ... = pₙ)

Пример: алфавит {A:0,5, B:0,5}
- Хартли: I = log₂(2) = 1
- Шеннон: I = -0,5·1 - 0,5·1 = 1 (совпадает)

Пример 2: алфавит {A:0,9, B:0,1}
- Хартли: I = log₂(2) = 1
- Шеннон: I ≈ 0,469 (меньше)

---

## Билет 42: Условная энтропия и её свойства

**Условная энтропия** H(Y|X) – средняя неопределённость Y при известном X:
- H(Y|X) = Σₓ p(x) · H(Y|X=x)
- H(Y|X) = -Σₓ,ᵧ p(x,y) · log₂(p(y|x))

**Свойства условной энтропии:**
1. H(Y|X) ≤ H(Y) (информация X уменьшает неопределённость Y)
2. H(Y|X) = 0 если Y полностью определяется X
3. H(X,Y) = H(X) + H(Y|X) = H(Y) + H(X|Y) (цепное правило)

Пример: два броска монеты
- H(X) = 1 бит (первый бросок)
- H(Y|X) = 1 бит (второй бросок независим)
- H(X,Y) = 2 бита

---

## Билет 43: Связь энтропии и информации

**Информация**, полученная при передаче сообщения:
- I = H(до) - H(после)

**Важные соотношения:**
1. I(X;Y) = H(X) - H(X|Y) = H(Y) - H(Y|X)
2. I(X;Y) = H(X) + H(Y) - H(X,Y) (взаимная информация)
3. 0 ≤ I(X;Y) ≤ min(H(X), H(Y))

Пример: при получении данных о событии:
- До: H(X) = 1 бит (50% вероятности)
- После: H(X|данные) = 0 бит (однозначно)
- Информация: I = 1 - 0 = 1 бит

---

## Билет 44: Взаимная информация и её свойства

**Взаимная информация** I(X;Y) – количество информации, которое X содержит о Y:
- I(X;Y) = Σₓ,ᵧ p(x,y) · log₂(p(x,y) / (p(x)·p(y)))

**Свойства взаимной информации:**
1. **Симметрия:** I(X;Y) = I(Y;X)
2. **Неотрицательность:** I(X;Y) ≥ 0
3. **Максимум:** I(X;Y) ≤ min(H(X), H(Y))
4. **Независимость:** I(X;Y) = 0 если X и Y независимы

Пример: бросание монеты
- X – первый бросок, Y – второй бросок
- I(X;Y) = 0 (независимы)

Пример 2: X – посев семян, Y – урожай
- I(X;Y) > 0 (зависимы)

---

## Билет 45: Дискретный двоичный канал без памяти

**Дискретный двоичный канал** передаёт биты с ошибками.

**Симметричный канал (BSC):**
- Вероятность ошибки: p (одинакова для 0→1 и 1→0)
- Матрица переходов:
```
      Вход    Выход
       0  ──0── 1-p
       │
       └──1── p
       1  ──1── 1-p
       │
       └──0── p
```

**Пропускная способность (capacity):**
- C = 1 - H(p) бит/символ

Пример: p = 0,1 (10% ошибок)
- C = 1 - H(0,1) = 1 - 0,469 ≈ 0,531 бит/символ

При p = 0,5 (случайный шум):
- C = 1 - 1 = 0 (канал бесполезен)

---

## Билет 46: Алгоритм построения дискретного канала без памяти

**Построение канала из более простых:**

1. **Параллельное соединение** – несколько каналов одновременно
   - Пропускная способность: C = C₁ + C₂ + ... + Cₙ

2. **Последовательное соединение** – выход одного → вход другого
   - Пропускная способность: C = min(C₁, C₂, ..., Cₙ)

3. **Расширение алфавита** – использование более крупных символов
   - Пропускная способность увеличивается

Пример: два симметричных канала с p = 0,1:
- Параллель: C = 2 × 0,531 ≈ 1,062 бит/символ
- Последовательность: C = 0,531 бит/символ

---

## Билет 47: Система передачи информации

**Структурная схема:**

```
Источник ──[Кодер]──[Канал]──[Декодер]── Получатель
 сигнала    (Шифр)   (Шум)   (Восстан.)    (Приёмник)
            │                    │
            └──[Синхрониз.]──┘
```

**Компоненты:**
1. **Источник** – сообщение (текст, звук, видео)
2. **Кодер** – преобразование в биты, сжатие, шифрование
3. **Модулятор** – адаптация к каналу
4. **Канал** – физическая среда (провод, радио, оптика)
5. **Шум** – помехи в канале
6. **Демодулятор** – восстановление сигнала
7. **Декодер** – восстановление исходного сообщения

---

## Билет 48: Кодирование произвольного источника в канале без шума

**Цель:** минимизировать среднюю длину кода.

**Условие Крафта** – необходимое условие существования однозначно декодируемого кода:
- Σ 2⁻ⁿᵢ ≤ 1

где nᵢ – длина кода для i-го символа.

**Оптимальная длина кода:**
- L_avg = Σ pᵢ · nᵢ ≥ H(X)

Пример: источник {A:0,5, B:0,25, C:0,25}
- H = 0,5·1 + 0,25·2 + 0,25·2 = 1,5 бита
- Код: A→0 (1 бит), B→10 (2 бита), C→11 (2 бита)
- L_avg = 0,5×1 + 0,25×2 + 0,25×2 = 1,5 бита (оптимально)

---

## Билет 49: Коды, исправляющие ошибки (коды Хэмминга)

**Коды Хэмминга** – добавляют проверочные биты для исправления ошибок.

**Для одиночной ошибки:**
- Количество проверочных битов: r = ⌈log₂(n+r+1)⌉
- где n – информационные биты

Пример: Хэмминг(7,4) – 7 битов кода на 4 информационные биты, 3 проверочные:

| Позиция | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
|---------|---|---|---|---|---|---|---|
| Бит     | p₁| p₂| d₁| p₃| d₂| d₃| d₄|

где p – проверочные, d – данные.

**Проверка:**
- p₁: позиции, где бит 0 = 1 (1,3,5,7)
- p₂: позиции, где бит 1 = 1 (2,3,6,7)
- p₃: позиции, где бит 2 = 1 (4,5,6,7)

При ошибке синдром указывает её позицию.

---

## Билет 50: Кодирование

**Кодирование** – преобразование данных в удобный для передачи вид.

**Типы кодирования:**

1. **По назначению:**
   - Кодирование источника (сжатие)
   - Кодирование канала (помехоустойчивость)
   - Криптографическое (шифрование)

2. **По методу:**
   - Равномерный код (фиксированная длина)
   - Неравномерный код (переменная длина)

3. **По свойствам:**
   - Однозначно декодируемый
   - Префиксный
   - Систематический

**Примеры:**
- ASCII – равномерный (8 бит на символ)
- UTF-8 – переменный (1-4 байта)
- Хаффман – оптимальный префиксный

---

## Билет 51: Метод Шеннона-Фано

**Алгоритм:**
1. Упорядочить символы по убыванию вероятностей
2. Разделить на две группы примерно равной суммарной вероятности
3. Первой группе присвоить 0, второй – 1
4. Рекурсивно повторить для каждой группы

Пример: {A:0,4, B:0,3, C:0,2, D:0,1}

```
Группа 1: A(0,4), B(0,3)  → 0
Группа 2: C(0,2), D(0,1)  → 1

A,B разделить:
A(0,4) → 00
B(0,3) → 01

C,D разделить:
C(0,2) → 10
D(0,1) → 11
```

Результат: A→00, B→01, C→10, D→11
L_avg = 0,4×2 + 0,3×2 + 0,2×2 + 0,1×2 = 2 бита

---

## Билет 52: Алгоритм Хаффмана

**Алгоритм:**
1. Упорядочить символы по возрастанию вероятностей
2. Объединить два символа с наименьшей вероятностью
3. Новому узлу присвоить сумму вероятностей
4. Повторить до получения одного узла
5. Выписать коды по пути от корня (0 влево, 1 вправо)

Пример: {A:0,4, B:0,3, C:0,2, D:0,1}

```
     1,0
    /   \
   0,7   A:0,4
  /   \
 0,4  0,3
 / \
D:0,1 C:0,2   B:0,3
```

Коды: A→0, B→10, C→110, D→111
L_avg = 0,4×1 + 0,3×2 + 0,2×3 + 0,1×3 = 1,9 бита

**Оптимальность:** L_avg ≤ H(X) + 1

---

## Билет 53: Плата DE10-Lite – основные элементы и ресурсы

**DE10-Lite** – учебная FPGA-плата на базе Intel/Altera Max 10.

**Базовый кристалл (FPGA):**
- FPGA Max 10 (10M50DAF484C7G)

**Ресурсы кристалла:**

1. **LE (Logic Elements)** – логические элементы
   - 49920 LE для реализации комбинационной и последовательностной логики
   - Каждый LE содержит LUT (таблица истинности) и FF (триггер)

2. **DSP (Digital Signal Processing)** – блоки обработки сигналов
   - Встроенные умножители и сумматоры
   - Для обработки аудио, видео, математических операций

3. **RAM (BRAM)** – встроенная оперативная память
   - M9K и M144K блоки памяти
   - Для хранения данных и программ

4. **PLL (Phase Locked Loop)** – синтезаторы частоты
   - Для генерации тактовых сигналов

**Внешняя периферия:**
- Светодиоды (LED)
- Кнопки (Switch, Button)
- Дисплей 7-segment
- Разъёмы GPIO
- Разъём USB
- SDRAM память

---

## Билет 54: Инструменты САПР Quartus II

**Quartus II** – интегрированная среда разработки для FPGA (Intel/Altera).

**Основные инструменты:**

1. **Project Navigator** – управление проектом
2. **Design Entry** – ввод проекта (HDL, схемы, диаграммы)
3. **Analysis & Synthesis** – синтез проекта
4. **Place & Route** – размещение и трассировка
5. **Timing Analysis** – анализ временных характеристик
6. **Power Analysis** – анализ энергопотребления
7. **Simulation** – моделирование (ModelSim)
8. **Programming & Configuration** – программирование кристалла

**Поддерживаемые языки:**
- Verilog
- VHDL
- Блок-диаграммы (Block Diagram)

---

## Билет 55: Основные файлы проекта в Quartus II

**Файлы проекта:**

1. **.qpf** – файл проекта (Project File)
   - Основной файл проекта, содержит настройки

2. **.qsf** – файл настроек (Settings File)
   - Настройки компиляции, назначение выводов, ограничения

3. **.v / .vhd** – исходные файлы (HDL)
   - Код на Verilog/VHDL

4. **.bdf** – блок-диаграмма (Block Diagram File)
   - Графическое представление схемы

5. **.sdc** – временные ограничения (Synopsys Design Constraints)
   - Временные параметры и ограничения

6. **.rbf / .sof / .jic** – файлы конфигурации
   - Для программирования FPGA

7. **.rpt** – отчёты (Report)
   - Результаты синтеза, размещения, анализа

8. **.wdb / .vwf** – файлы моделирования (Waveform)
   - Для симуляции и анализа сигналов

---

## Билет 56: Задачи ИИ и области применения

**Задачи ИИ:**
1. Обработка естественного языка (NLP)
2. Компьютерное зрение (CV)
3. Распознавание речи
4. Игры и поиск (Game AI, Search)
5. Робототехника
6. Экспертные системы

**Области применения:**

1. **Медицина** – диагностика, прогноз, лечение
2. **Финансы** – прогнозирование, торговля, риск-менеджмент
3. **Транспорт** – беспилотные автомобили, оптимизация маршрутов
4. **Производство** – автоматизация, контроль качества, оптимизация
5. **Образование** – адаптивное обучение, автоматическая проверка
6. **Развлечения** – игры, рекомендации, содержание
7. **Безопасность** – системы наблюдения, обнаружение аномалий
8. **Сельское хозяйство** – мониторинг урожая, прогнозирование

---

## Билет 57: Алгоритмы машинного обучения

**Типы обучения:**

1. **Контролируемое обучение** (Supervised Learning)
   - Регрессия: предсказание непрерывных значений (линейная регрессия, SVM)
   - Классификация: разделение на классы (логистическая регрессия, деревья решений, случайный лес)

2. **Неконтролируемое обучение** (Unsupervised Learning)
   - Кластеризация: группировка похожих объектов (K-means, DBSCAN, иерархическая)
   - Снижение размерности: PCA, t-SNE

3. **Обучение с подкреплением** (Reinforcement Learning)
   - Q-learning, Policy Gradient, Actor-Critic
   - Применение: игры, робототехника

**Основные алгоритмы:**
- **Решающие деревья** – интерпретируемые, быстрые
- **Случайный лес** – ансамбль деревьев, высокая точность
- **SVM** – для классификации и регрессии
- **Нейронные сети** – универсальные аппроксиматоры
- **K-NN** – простой и эффективный

---

## Билет 58: Работа с текстами

**Обработка текста (NLP):**

1. **Предварительная обработка:**
   - Токенизация – разделение на слова
   - Нормализация – приведение к нижнему регистру
   - Удаление стоп-слов и пунктуации
   - Стемминг/лемматизация – приведение к корневой форме

2. **Представление текста:**
   - Bag of Words (BoW) – подсчёт слов
   - TF-IDF – взвешивание по важности
   - Word Embeddings (Word2Vec, GloVe) – векторное представление
   - Transformer models (BERT, GPT) – контекстные представления

3. **Задачи:**
   - Классификация (спам, тональность)
   - Извлечение информации (Named Entity Recognition)
   - Машинный перевод
   - Ответ на вопросы
   - Генерация текста

**Примеры:**
```
Текст: "The quick brown fox"
Tokens: ["The", "quick", "brown", "fox"]
BoW: {the: 1, quick: 1, brown: 1, fox: 1}
```

---

## Билет 59: Работа с изображениями

**Компьютерное зрение (CV):**

1. **Основные операции:**
   - Фильтрация (размытие, краевые фильтры)
   - Морфологические операции (эрозия, дилатация)
   - Трансформации (масштабирование, поворот, искажение)

2. **Детекция и классификация:**
   - Детекция объектов (YOLO, R-CNN, SSD)
   - Классификация изображений (CNN: ResNet, VGG, MobileNet)
   - Семантическая сегментация – классификация каждого пикселя
   - Поиск признаков (ORB, SIFT, SURF)

3. **Специализированные задачи:**
   - Распознавание лиц (Dlib, FaceNet)
   - Поза человека (OpenPose)
   - Оптическое распознавание символов (OCR)
   - Генерация изображений (GAN, Diffusion Models)

**Процесс:**
```
Входное изображение → Предобработка → Признаки → Модель → Результат
```

---

## Билет 60: Работа с видео и аудио

**Обработка видео:**

1. **Основные операции:**
   - Кодирование/декодирование (H.264, VP9, AV1)
   - Сжатие видеопотока
   - Извлечение кадров
   - Ускорение видео, замедление

2. **Анализ видео:**
   - Слежение за объектами (Object Tracking)
   - Распознавание действий (Action Recognition)
   - Обнаружение движения (Motion Detection)
   - Анализ жестов
   - Видеоанализ для безопасности

3. **Применение:**
   - Видеоконференции
   - Потоковое вещание
   - Редактирование видео
   - Медицинская диагностика

**Обработка аудио:**

1. **Основные операции:**
   - Дискретизация (Sampling): преобразование аналогового в цифровое
   - Квантование (Quantization): округление уровней громкости
   - Кодирование (MP3, AAC, FLAC)

2. **Анализ аудио:**
   - Спектрограмма (Spectrogram) – частотно-временное представление
   - MFCC (Mel-frequency cepstral coefficients) – признаки для речи
   - Распознавание речи (Speech Recognition)
   - Классификация звуков
   - Выделение речи из шума (Noise Reduction)

3. **Применение:**
   - Голосовые ассистенты (Alexa, Siri)
   - Музыкальные рекомендации
   - Медицинская диагностика (анализ дыхания, кашля)
   - Аудиокниги и синтез речи (TTS)

**Интеграция видео и аудио:**
- Синхронизация видео- и аудиопотоков
- Синтез видеоконтента с аудиодорожкой
- Анализ мультимодальных данных

---

## Заключение

Данный документ содержит подробные ответы на все 60 билетов по информатике, охватывающие:
- Системы счисления и методы перевода
- Машинные коды и арифметические операции
- Представление чисел в ЭВМ
- Булева алгебра и логические схемы
- Теория информации и кодирование
- FPGA и цифровой дизайн
- Искусственный интеллект и машинное обучение
- Обработка текстов, изображений, видео и аудио

Каждый ответ содержит теоретическое объяснение, практические примеры и применение изученного материала.
